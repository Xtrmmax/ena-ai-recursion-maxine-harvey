# Calendar Engine Executive Summary

> Note: Before March 2025 my only experience in Python was getting to Day 8 of 100 Days of Coding on Udemy.  
> Using “vibe coding” and trial-and-error iteration with AI assistants, I built a **deterministic behavioral calendar engine** with more than ten interlocking mechanisms (cyclical offsets, leap years, time zones, symbolic mapping, and exception handling).  
> I still don’t know most of the terminology,  but I know how to build complex logic until it works.

## Overview
Developed **March – June 2025** with refinements through August.  
The calendar system encodes **10 + mathematical and symbolic mechanisms**, translating birth date and time into **predictive behavioral and personality outputs** based on the **Mexica (Aztec) calendar**.

Unlike the Gregorian calendar, it is not a linear calculation.  
Each subsystem — time conversion, cyclical offset, and symbolic interpretation — had to be solved, tested, and integrated before the engine could generate consistent personality archetypes.

## What’s Here
- Pseudocode overview of the proprietary calendar engine (core logic stored privately)  
- Example outputs showing **deterministic personality and behavioral profiles**  
- Dataset generator sample and summary files (full dataset archived privately)

## Results
- Generated thousands of consistent, deterministic personality outputs  
- Created large-scale symbolic datasets suitable for downstream fine-tuning and modeling  
- Validated deterministic recurrence across complex time-symbol mappings

## Reflection
This was my most difficult and formative technical build.  
It taught me **systemic debugging, symbolic logic design, and deterministic computation** — the same principles I later applied to the **Temporal Need Engine (TNE)** inside ENA.ai Recursion.  
That bridge from symbolic personality modeling to mathematical emotion regulation shaped the foundation of the ENA.ai architecture.