# Calendar Engine

For a quick overview, see the: [Calendar Executive Summary](./EXECUTIVE_SUMMARY.md)

> Note: Before March 2025 my only experience in Python was getting to Day 8 of 100 Days of Coding on Udemy.  
> Using “vibe coding” and trial-and-error iteration with AI assistants I built a calendar engine with at least 10 mathematical mechanisms (cyclical offsets, leap years, time zones, exception handling, etc.).  
> I still don’t know how to code, but I learned how to layer complex logic and debug one piece at a time until the whole system worked.

## Overview
From **March–June 2025**, I built a custom calendar engine as my second major technical project.  
Unlike the Gregorian calendar, this system required **10+ interdependent mechanisms** (cyclical offsets, modular resets, leap year adjustments, time-zone conversions, exception handling).  

Each piece had to be coded, tested, and debugged in layers until the system worked end-to-end.

## What’s Here
- `calendar_engine.py` → core Python code  
- `/datasets` → simplified JSON input files used by the engine  
- `/outputs` → generated calendar outputs and dataset generator results  

## Results
- Completed a working calendar system with deterministic outputs.  
- Debugged across multiple interlocking layers (each mechanism depended on the last).  
- Extended the system in **Jul–Aug 2025** into a **Bitcoin price movement predictor** (manual Excel prototype for now).  

## Reflection
This project pushed me to think modularly, integrate carefully, and debug systematically.  
It became the foundation for how I now approach fine-tuning and more advanced AI experiments.

## Next Steps
- Code the Bitcoin predictor (currently manual in Excel).  
- Integrate calendar outputs into training datasets for future fine-tuned models.  


