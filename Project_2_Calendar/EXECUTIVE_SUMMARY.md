# Calendar Engine Executive Summary

> Note: Before March 2025 my only experience in Python was getting to Day 8 of 100 Days of Coding on Udemy.  
> Using “vibe coding” and trial-and-error iteration with AI assistants I built a calendar engine with at least 10 mathematical mechanisms (cyclical offsets, leap years, time zones, exception handling, etc.).  
> I still don’t know how to code, but I learned how to layer complex logic and debug one piece at a time until the whole system worked.

## Overview
Built **Mar–Jun 2025** with minor improvements through August.  
The calendar system encodes **10+ interdependent mechanisms** — cyclical offsets, modular resets, leap year adjustments, time-zone conversions, exception handling, and more.  

Unlike the Gregorian calendar, there is no single linear formula. Each module had to be solved in sequence, tested, and integrated before the system worked.

## What’s Here
- Scripts for the core calendar logic and dataset generation  
- Outputs including example runs and a full **3,000-entry dataset** (plus a readable sample)  

## Results
- Produced consistent outputs across thousands of test cases  
- Generated large datasets for downstream fine-tuning and prediction experiments  

## Reflection
This was my most challenging technical project to date.  
It sharpened my skills in **vibe coding, debugging, modular design, and dataset creation**, and gave me the confidence to approach complex deterministic systems.  
Those skills now strengthen my return to fine-tuning work.
